<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/myapplication3/BleService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/myapplication3/BleService.kt" />
              <option name="originalContent" value="package com.example.myapplication3&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.app.*&#10;import android.bluetooth.*&#10;import android.bluetooth.le.*&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Binder&#10;import android.os.Build&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.os.ParcelUuid&#10;import android.util.Log&#10;import androidx.annotation.RequiresApi&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.content.ContextCompat&#10;import com.example.myapplication3.BleRole.*&#10;import java.util.UUID&#10;import java.util.concurrent.ConcurrentHashMap&#10;&#10;@SuppressLint(&quot;MissingPermission&quot;)&#10;class BleConnectionsService : Service() {&#10;&#10;    private val TAG = &quot;BleService&quot;&#10;    private val NOTIFICATION_ID = 2001&#10;    private val CHANNEL_ID = &quot;ble_connections_channel&quot;&#10;&#10;    // BLE Constants&#10;    private val SERVICE_UUID = UUID.fromString(&quot;6E400001-B5A3-F393-E0A9-E50E24DCCA9E&quot;)&#10;    private val CHARACTERISTIC_UUID_WRITE = UUID.fromString(&quot;00001102-0000-1000-8000-00805F9B34FB&quot;)&#10;    private val CHARACTERISTIC_UUID_NOTIFY = UUID.fromString(&quot;00001103-0000-1000-8000-00805F9B34FB&quot;)&#10;    private val CHARACTERISTIC_UUID_READ = UUID.fromString(&quot;00001104-0000-1000-8000-00805F9B34FB&quot;)&#10;    private val CCCD_UUID = UUID.fromString(&quot;00002902-0000-1000-8000-00805f9b34fb&quot;)&#10;&#10;    private val binder = LocalBinder()&#10;    private val handler = Handler(Looper.getMainLooper())&#10;&#10;    // BLE Managers&#10;    private var bluetoothManager: BluetoothManager? = null&#10;    private var bluetoothAdapter: BluetoothAdapter? = null&#10;    private var bleScanner: BluetoothLeScanner? = null&#10;    private var gattServer: BluetoothGattServer? = null&#10;    private var advertiser: BluetoothLeAdvertiser? = null&#10;&#10;    // State&#10;    var currentRole = IDLE&#10;        private set&#10;    var isScanning = false&#10;        private set&#10;    var isAdvertising = false&#10;        private set&#10;&#10;    // Data structures&#10;    private val discoveredDeviceMap = ConcurrentHashMap&lt;String, DiscoveredDevice&gt;()&#10;    private val connectedGattClients = ConcurrentHashMap&lt;String, ConnectedDevice&gt;()&#10;    private val connectedClientMap = ConcurrentHashMap&lt;String, BluetoothDevice&gt;()&#10;&#10;    // Characteristics&#10;    private var writeCharacteristicServer: BluetoothGattCharacteristic? = null&#10;    private var notifyCharacteristicServer: BluetoothGattCharacteristic? = null&#10;    private var readCharacteristicServer: BluetoothGattCharacteristic? = null&#10;&#10;    // Callbacks&#10;    var onRoleChanged: ((BleRole) -&gt; Unit)? = null&#10;    var onScanningStateChanged: ((Boolean) -&gt; Unit)? = null&#10;    var onAdvertisingStateChanged: ((Boolean) -&gt; Unit)? = null&#10;    var onDevicesDiscovered: ((List&lt;DiscoveredDevice&gt;) -&gt; Unit)? = null&#10;    var onDevicesConnected: ((List&lt;ConnectedDevice&gt;) -&gt; Unit)? = null&#10;    var onClientsConnected: ((List&lt;BluetoothDevice&gt;) -&gt; Unit)? = null&#10;    var onLogMessage: ((String) -&gt; Unit)? = null&#10;    var onMessageReceived: ((String) -&gt; Unit)? = null&#10;&#10;    inner class LocalBinder : Binder() {&#10;        fun getService(): BleConnectionsService = this@BleConnectionsService&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.d(TAG, &quot;BLE Service created&quot;)&#10;        bluetoothManager = getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager&#10;        bluetoothAdapter = bluetoothManager?.adapter&#10;        createNotificationChannel()&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder {&#10;        Log.d(TAG, &quot;Service bound&quot;)&#10;        return binder&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        Log.d(TAG, &quot;Service started&quot;)&#10;        startForeground(NOTIFICATION_ID, createNotification(&quot;BLE Connections Active&quot;))&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;BLE Connections&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Running BLE Connections in background&quot;&#10;            }&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;            Log.d(TAG, &quot;Notification channel created&quot;)&#10;        }&#10;    }&#10;&#10;    private fun createNotification(message: String): Notification {&#10;        val notificationIntent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this,&#10;            0,&#10;            notificationIntent,&#10;            PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        return NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;BLE Connections&quot;)&#10;            .setContentText(message)&#10;            .setSmallIcon(android.R.drawable.stat_notify_sync)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .build()&#10;    }&#10;&#10;    private fun updateNotification(message: String) {&#10;        val notificationManager = getSystemService(NotificationManager::class.java)&#10;        notificationManager.notify(NOTIFICATION_ID, createNotification(message))&#10;        Log.d(TAG, &quot;Notification updated: $message&quot;)&#10;    }&#10;&#10;    private fun log(message: String) {&#10;        Log.d(TAG, message)&#10;        onLogMessage?.invoke(message)&#10;    }&#10;&#10;    private fun hasPermission(permission: String): Boolean {&#10;        return ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    // ============================================&#10;    // ROLE MANAGEMENT&#10;    // ============================================&#10;&#10;    fun setRole(role: BleRole) {&#10;        if (currentRole == role) return&#10;&#10;        stopCurrentRole()&#10;        currentRole = role&#10;        log(&quot;Switched role to: $role&quot;)&#10;        onRoleChanged?.invoke(role)&#10;&#10;        when (role) {&#10;            CENTRAL -&gt; {&#10;                isAdvertising = false&#10;                connectedClientMap.clear()&#10;                onClientsConnected?.invoke(emptyList())&#10;                updateNotification(&quot;Central Mode&quot;)&#10;            }&#10;            PERIPHERAL -&gt; {&#10;                isScanning = false&#10;                discoveredDeviceMap.clear()&#10;                connectedGattClients.clear()&#10;                onDevicesDiscovered?.invoke(emptyList())&#10;                onDevicesConnected?.invoke(emptyList())&#10;                updateNotification(&quot;Peripheral Mode&quot;)&#10;            }&#10;            IDLE -&gt; {&#10;                updateNotification(&quot;BLE Connections Active&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopCurrentRole() {&#10;        when (currentRole) {&#10;            CENTRAL -&gt; stopCentral()&#10;            PERIPHERAL -&gt; stopPeripheral()&#10;            IDLE -&gt; {}&#10;        }&#10;    }&#10;&#10;    // ============================================&#10;    // CENTRAL ROLE&#10;    // ============================================&#10;&#10;    @RequiresApi(Build.VERSION_CODES.O)&#10;    fun startCentralScan() {&#10;        if (currentRole != CENTRAL) {&#10;            log(&quot;Not in Central role&quot;)&#10;            return&#10;        }&#10;        if (isScanning) {&#10;            log(&quot;Already scanning&quot;)&#10;            return&#10;        }&#10;        if (!hasPermission(Manifest.permission.BLUETOOTH_SCAN)) {&#10;            log(&quot;BLUETOOTH_SCAN permission missing&quot;)&#10;            return&#10;        }&#10;&#10;        bleScanner = bluetoothAdapter?.bluetoothLeScanner&#10;        if (bleScanner == null) {&#10;            log(&quot;Failed to get BLE Scanner&quot;)&#10;            return&#10;        }&#10;&#10;        discoveredDeviceMap.clear()&#10;        onDevicesDiscovered?.invoke(emptyList())&#10;&#10;        val scanFilter = ScanFilter.Builder()&#10;            .setServiceUuid(ParcelUuid(SERVICE_UUID))&#10;            .build()&#10;&#10;        val scanSettings = ScanSettings.Builder()&#10;            .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)&#10;            .setLegacy(true)&#10;            .build()&#10;&#10;        log(&quot;Starting BLE Scan...&quot;)&#10;        isScanning = true&#10;        onScanningStateChanged?.invoke(true)&#10;        updateNotification(&quot;Scanning for devices...&quot;)&#10;&#10;        bleScanner?.startScan(listOf(scanFilter), scanSettings, scanCallback)&#10;    }&#10;&#10;    fun stopCentralScan() {&#10;        if (!isScanning) return&#10;        log(&quot;Stopping BLE Scan&quot;)&#10;        bleScanner?.stopScan(scanCallback)&#10;        isScanning = false&#10;        onScanningStateChanged?.invoke(false)&#10;        updateNotification(&quot;Central Mode&quot;)&#10;    }&#10;&#10;    fun connectToDevice(device: BluetoothDevice) {&#10;        if (currentRole != CENTRAL) {&#10;            log(&quot;Cannot connect: Not in Central role&quot;)&#10;            updateNotification(&quot;Cannot connect: Not in Central role&quot;)&#10;            return&#10;        }&#10;        if (!hasPermission(Manifest.permission.BLUETOOTH_CONNECT)) {&#10;            log(&quot;BLUETOOTH_CONNECT permission missing&quot;)&#10;            updateNotification(&quot;BLUETOOTH_CONNECT permission missing&quot;)&#10;            return&#10;        }&#10;&#10;        if (connectedGattClients.containsKey(device.address)) {&#10;            log(&quot;Already connected to ${device.address}&quot;)&#10;            updateNotification(&quot;Already connected to ${device.address}&quot;)&#10;            return&#10;        }&#10;&#10;        log(&quot;Connecting to device: ${device.address}&quot;)&#10;        val gatt = device.connectGatt(this, false, gattClientCallback)&#10;        connectedGattClients[device.address] = ConnectedDevice(device, gatt)&#10;        onDevicesConnected?.invoke(connectedGattClients.values.toList())&#10;        updateNotification(&quot;Connecting to ${device.name ?: device.address}&quot;)&#10;    }&#10;&#10;    fun disconnectCentral() {&#10;        if (currentRole != CENTRAL) return&#10;&#10;        log(&quot;Disconnecting all devices&quot;)&#10;        connectedGattClients.values.forEach { connectedDevice -&gt;&#10;            connectedDevice.gatt.disconnect()&#10;            connectedDevice.gatt.close()&#10;        }&#10;        connectedGattClients.clear()&#10;        onDevicesConnected?.invoke(emptyList())&#10;        updateNotification(&quot;Central Mode&quot;)&#10;    }&#10;&#10;    private fun stopCentral() {&#10;        log(&quot;Stopping Central Role...&quot;)&#10;        stopCentralScan()&#10;        disconnectCentral()&#10;        isScanning = false&#10;        discoveredDeviceMap.clear()&#10;        onDevicesDiscovered?.invoke(emptyList())&#10;    }&#10;&#10;    // ============================================&#10;    // PERIPHERAL ROLE&#10;    // ============================================&#10;&#10;    fun startPeripheralAdvertising() {&#10;        if (currentRole != PERIPHERAL) {&#10;            log(&quot;Not in Peripheral role&quot;)&#10;            return&#10;        }&#10;        if (isAdvertising) {&#10;            log(&quot;Already advertising&quot;)&#10;            return&#10;        }&#10;        if (!hasPermission(Manifest.permission.BLUETOOTH_ADVERTISE)) {&#10;            log(&quot;BLUETOOTH_ADVERTISE permission missing&quot;)&#10;            return&#10;        }&#10;&#10;        advertiser = bluetoothAdapter?.bluetoothLeAdvertiser&#10;        if (advertiser == null) {&#10;            log(&quot;Failed to get BLE Advertiser&quot;)&#10;            return&#10;        }&#10;&#10;        if (!setupGattServer()) {&#10;            log(&quot;Failed to setup GATT Server&quot;)&#10;            return&#10;        }&#10;&#10;        val settings = AdvertiseSettings.Builder()&#10;            .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY)&#10;            .setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH)&#10;            .setConnectable(true)&#10;            .build()&#10;&#10;        val data = AdvertiseData.Builder()&#10;            .setIncludeDeviceName(false)&#10;            .addServiceUuid(ParcelUuid(SERVICE_UUID))&#10;            .build()&#10;&#10;        val scanResponse = AdvertiseData.Builder()&#10;            .setIncludeDeviceName(true)&#10;            .build()&#10;&#10;        log(&quot;Starting Advertising...&quot;)&#10;        updateNotification(&quot;Starting advertising...&quot;)&#10;        advertiser?.startAdvertising(settings, data, scanResponse, advertiseCallback)&#10;    }&#10;&#10;    fun stopPeripheralAdvertising() {&#10;        if (!isAdvertising) return&#10;        log(&quot;Stopping Advertising&quot;)&#10;        advertiser?.stopAdvertising(advertiseCallback)&#10;        isAdvertising = false&#10;        onAdvertisingStateChanged?.invoke(false)&#10;        updateNotification(&quot;Peripheral Mode&quot;)&#10;    }&#10;&#10;    private fun setupGattServer(): Boolean {&#10;        if (gattServer != null) {&#10;            log(&quot;GATT Server already running&quot;)&#10;            return true&#10;        }&#10;&#10;        gattServer = bluetoothManager?.openGattServer(this, gattServerCallback)&#10;        if (gattServer == null) {&#10;            log(&quot;Failed to open GATT Server&quot;)&#10;            return false&#10;        }&#10;&#10;        val service = BluetoothGattService(SERVICE_UUID, BluetoothGattService.SERVICE_TYPE_PRIMARY)&#10;&#10;        writeCharacteristicServer = BluetoothGattCharacteristic(&#10;            CHARACTERISTIC_UUID_WRITE,&#10;            BluetoothGattCharacteristic.PROPERTY_WRITE or BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE,&#10;            BluetoothGattCharacteristic.PERMISSION_WRITE&#10;        )&#10;&#10;        readCharacteristicServer = BluetoothGattCharacteristic(&#10;            CHARACTERISTIC_UUID_READ,&#10;            BluetoothGattCharacteristic.PROPERTY_READ,&#10;            BluetoothGattCharacteristic.PERMISSION_READ&#10;        )&#10;&#10;        notifyCharacteristicServer = BluetoothGattCharacteristic(&#10;            CHARACTERISTIC_UUID_NOTIFY,&#10;            BluetoothGattCharacteristic.PROPERTY_READ or BluetoothGattCharacteristic.PROPERTY_NOTIFY,&#10;            BluetoothGattCharacteristic.PERMISSION_READ&#10;        )&#10;&#10;        val cccdDescriptor = BluetoothGattDescriptor(&#10;            CCCD_UUID,&#10;            BluetoothGattDescriptor.PERMISSION_READ or BluetoothGattDescriptor.PERMISSION_WRITE&#10;        )&#10;        notifyCharacteristicServer?.addDescriptor(cccdDescriptor)&#10;        readCharacteristicServer?.addDescriptor(cccdDescriptor)&#10;&#10;        service.addCharacteristic(writeCharacteristicServer)&#10;        service.addCharacteristic(notifyCharacteristicServer)&#10;        service.addCharacteristic(readCharacteristicServer)&#10;&#10;        val serviceAdded = gattServer?.addService(service) ?: false&#10;        if (serviceAdded) {&#10;            log(&quot;GATT Service added successfully&quot;)&#10;            return true&#10;        } else {&#10;            log(&quot;Failed to add GATT Service&quot;)&#10;            gattServer?.close()&#10;            gattServer = null&#10;            return false&#10;        }&#10;    }&#10;&#10;    private fun stopGattServer() {&#10;        if (gattServer == null) return&#10;        log(&quot;Closing GATT Server&quot;)&#10;        gattServer?.close()&#10;        gattServer = null&#10;        writeCharacteristicServer = null&#10;        notifyCharacteristicServer = null&#10;        connectedClientMap.clear()&#10;        onClientsConnected?.invoke(emptyList())&#10;    }&#10;&#10;    private fun stopPeripheral() {&#10;        log(&quot;Stopping Peripheral Role...&quot;)&#10;        stopPeripheralAdvertising()&#10;        stopGattServer()&#10;        isAdvertising = false&#10;        connectedClientMap.clear()&#10;        onClientsConnected?.invoke(emptyList())&#10;    }&#10;&#10;    // ============================================&#10;    // MESSAGING&#10;    // ============================================&#10;&#10;    fun sendMessage(message: String) {&#10;        if (message.isEmpty()) {&#10;            log(&quot;Message is empty&quot;)&#10;            return&#10;        }&#10;        val data = message.toByteArray(Charsets.UTF_8)&#10;&#10;        when (currentRole) {&#10;            CENTRAL -&gt; {&#10;                if (connectedGattClients.isEmpty()) {&#10;                    log(&quot;No devices connected&quot;)&#10;                    return&#10;                }&#10;                log(&quot;Sending message to ${connectedGattClients.size} devices&quot;)&#10;&#10;                connectedGattClients.forEach { (address, connectedDevice) -&gt;&#10;                    val writeChar = connectedDevice.writeCharacteristic&#10;                    if (writeChar != null) {&#10;                        writeChar.value = data&#10;                        writeChar.writeType = if (writeChar.properties and BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE != 0) {&#10;                            BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE&#10;                        } else {&#10;                            BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT&#10;                        }&#10;                        connectedDevice.gatt.writeCharacteristic(writeChar)&#10;                        log(&quot;Sending to $address&quot;)&#10;                        updateNotification(&quot;Sending to $address&quot;)&#10;                    } else {&#10;                        log(&quot;Write characteristic not found for $address&quot;)&#10;                        updateNotification(&quot;Write characteristic not found for $address&quot;)&#10;                    }&#10;                }&#10;            }&#10;            PERIPHERAL -&gt; {&#10;                if (gattServer == null || notifyCharacteristicServer == null || connectedClientMap.isEmpty()) {&#10;                    log(&quot;No clients connected&quot;)&#10;                    return&#10;                }&#10;                log(&quot;Notifying ${connectedClientMap.size} clients&quot;)&#10;&#10;                notifyCharacteristicServer?.value = data&#10;                connectedClientMap.values.forEach { device -&gt;&#10;                    val indicate = (notifyCharacteristicServer!!.properties and BluetoothGattCharacteristic.PROPERTY_INDICATE) != 0&#10;                    gattServer?.notifyCharacteristicChanged(device, notifyCharacteristicServer, indicate)&#10;                }&#10;            }&#10;            IDLE -&gt; log(&quot;Cannot send message in IDLE mode&quot;)&#10;        }&#10;    }&#10;&#10;    // ============================================&#10;    // SCAN CALLBACK&#10;    // ============================================&#10;&#10;    private val scanCallback = object : ScanCallback() {&#10;        override fun onScanResult(callbackType: Int, result: ScanResult) {&#10;            val device = result.device&#10;            val deviceName = result.scanRecord?.deviceName ?: device.name ?: &quot;Unknown&quot;&#10;            val deviceAddress = device.address&#10;&#10;            if (!discoveredDeviceMap.containsKey(deviceAddress)) {&#10;                log(&quot;Discovered: $deviceName ($deviceAddress)&quot;)&#10;                val discovered = DiscoveredDevice(deviceName, deviceAddress, device)&#10;                discoveredDeviceMap[deviceAddress] = discovered&#10;                onDevicesDiscovered?.invoke(discoveredDeviceMap.values.toList())&#10;            }&#10;        }&#10;&#10;        override fun onBatchScanResults(results: List&lt;ScanResult&gt;) {&#10;            results.forEach { result -&gt;&#10;                val device = result.device&#10;                val deviceName = result.scanRecord?.deviceName ?: device.name ?: &quot;Unknown&quot;&#10;                val deviceAddress = device.address&#10;                if (!discoveredDeviceMap.containsKey(deviceAddress)) {&#10;                    log(&quot;Discovered Batch: $deviceName ($deviceAddress)&quot;)&#10;                    discoveredDeviceMap[deviceAddress] = DiscoveredDevice(deviceName, deviceAddress, device)&#10;                }&#10;            }&#10;            onDevicesDiscovered?.invoke(discoveredDeviceMap.values.toList())&#10;        }&#10;&#10;        override fun onScanFailed(errorCode: Int) {&#10;            log(&quot;Scan Failed: Error Code $errorCode&quot;)&#10;            isScanning = false&#10;            onScanningStateChanged?.invoke(false)&#10;            updateNotification(&quot;Scan failed&quot;)&#10;        }&#10;    }&#10;&#10;    // ============================================&#10;    // GATT CLIENT CALLBACK&#10;    // ============================================&#10;&#10;    private val gattClientCallback = object : BluetoothGattCallback() {&#10;        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {&#10;            val deviceAddress = gatt.device.address&#10;            when (newState) {&#10;                BluetoothProfile.STATE_CONNECTED -&gt; {&#10;                    if (status == BluetoothGatt.GATT_SUCCESS) {&#10;                        log(&quot;Connected to $deviceAddress&quot;)&#10;                        connectedGattClients[deviceAddress] = ConnectedDevice(gatt.device, gatt)&#10;                        onDevicesConnected?.invoke(connectedGattClients.values.toList())&#10;                        updateNotification(&quot;Connected to ${gatt.device.name ?: deviceAddress}&quot;)&#10;&#10;                        log(&quot;Discovering services for $deviceAddress&quot;)&#10;                        val servicesDiscovered = gatt.discoverServices()&#10;                        if (!servicesDiscovered) {&#10;                            log(&quot;Failed to start service discovery&quot;)&#10;                            connectedGattClients.remove(deviceAddress)&#10;                            gatt.close()&#10;                            onDevicesConnected?.invoke(connectedGattClients.values.toList())&#10;                        }&#10;                    } else {&#10;                        log(&quot;Connection failed with status $status&quot;)&#10;                        connectedGattClients.remove(deviceAddress)&#10;                        gatt.close()&#10;                        onDevicesConnected?.invoke(connectedGattClients.values.toList())&#10;                    }&#10;                }&#10;                BluetoothProfile.STATE_DISCONNECTED -&gt; {&#10;                    log(&quot;Disconnected from $deviceAddress&quot;)&#10;                    connectedGattClients.remove(deviceAddress)&#10;                    gatt.close()&#10;                    onDevicesConnected?.invoke(connectedGattClients.values.toList())&#10;                    updateNotification(&quot;Device disconnected&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {&#10;            val deviceAddress = gatt.device.address&#10;            if (status == BluetoothGatt.GATT_SUCCESS) {&#10;                log(&quot;Services discovered for $deviceAddress&quot;)&#10;                val service = gatt.getService(SERVICE_UUID)&#10;                if (service != null) {&#10;                    val writeChar = service.getCharacteristic(CHARACTERISTIC_UUID_WRITE)&#10;                    val readChar = service.getCharacteristic(CHARACTERISTIC_UUID_READ)&#10;&#10;                    connectedGattClients[deviceAddress]?.let { connectedDevice -&gt;&#10;                        connectedDevice.writeCharacteristic = writeChar&#10;                        connectedDevice.readCharacteristic = readChar&#10;                        onDevicesConnected?.invoke(connectedGattClients.values.toList())&#10;                    }&#10;                } else {&#10;                    log(&quot;Service not found for $deviceAddress&quot;)&#10;                }&#10;            } else {&#10;                log(&quot;Service discovery failed with status $status&quot;)&#10;            }&#10;        }&#10;&#10;        override fun onCharacteristicWrite(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {&#10;            val deviceAddress = gatt.device.address&#10;            if (status == BluetoothGatt.GATT_SUCCESS) {&#10;                log(&quot;Write successful for $deviceAddress&quot;)&#10;                updateNotification(&quot;Write successful for $deviceAddress&quot;)&#10;            } else {&#10;                log(&quot;Write failed for $deviceAddress with status: $status&quot;)&#10;                updateNotification(&quot;Write failed for $deviceAddress with status: $status&quot;)&#10;            }&#10;        }&#10;&#10;        override fun onCharacteristicChanged(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, value: ByteArray) {&#10;            if (characteristic.uuid == CHARACTERISTIC_UUID_NOTIFY || characteristic.uuid == CHARACTERISTIC_UUID_READ) {&#10;                val receivedMessage = value.toString(Charsets.UTF_8)&#10;                log(&quot;Received: $receivedMessage&quot;)&#10;                onMessageReceived?.invoke(receivedMessage)&#10;                updateNotification(receivedMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    // ============================================&#10;    // ADVERTISE CALLBACK&#10;    // ============================================&#10;&#10;    private val advertiseCallback = object : AdvertiseCallback() {&#10;        override fun onStartSuccess(settingsInEffect: AdvertiseSettings) {&#10;            log(&quot;Advertising started successfully&quot;)&#10;            isAdvertising = true&#10;            onAdvertisingStateChanged?.invoke(true)&#10;            updateNotification(&quot;Advertising...&quot;)&#10;        }&#10;&#10;        override fun onStartFailure(errorCode: Int) {&#10;            log(&quot;Advertising failed: Error Code $errorCode&quot;)&#10;            isAdvertising = false&#10;            onAdvertisingStateChanged?.invoke(false)&#10;            updateNotification(&quot;Advertising failed&quot;)&#10;        }&#10;    }&#10;&#10;    // ============================================&#10;    // GATT SERVER CALLBACK&#10;    // ============================================&#10;&#10;    private val gattServerCallback = object : BluetoothGattServerCallback() {&#10;        override fun onConnectionStateChange(device: BluetoothDevice, status: Int, newState: Int) {&#10;            val deviceAddress = device.address&#10;            if (newState == BluetoothProfile.STATE_CONNECTED) {&#10;                log(&quot;Client connected: $deviceAddress&quot;)&#10;                connectedClientMap[deviceAddress] = device&#10;                onClientsConnected?.invoke(connectedClientMap.values.toList())&#10;                updateNotification(&quot;Client connected: ${device.name ?: deviceAddress}&quot;)&#10;                stopPeripheralAdvertising()&#10;            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {&#10;                log(&quot;Client disconnected: $deviceAddress&quot;)&#10;                connectedClientMap.remove(deviceAddress)&#10;                onClientsConnected?.invoke(connectedClientMap.values.toList())&#10;                updateNotification(&quot;Client disconnected&quot;)&#10;                startPeripheralAdvertising()&#10;            }&#10;        }&#10;&#10;        override fun onCharacteristicReadRequest(device: BluetoothDevice, requestId: Int, offset: Int, characteristic: BluetoothGattCharacteristic) {&#10;            log(&quot;Read request from ${device.address}&quot;)&#10;            var responseValue: ByteArray? = null&#10;            var responseStatus = BluetoothGatt.GATT_FAILURE&#10;&#10;            if (characteristic.uuid == CHARACTERISTIC_UUID_READ) {&#10;                responseValue = &quot;Time: ${System.currentTimeMillis()}&quot;.toByteArray(Charsets.UTF_8)&#10;                responseStatus = BluetoothGatt.GATT_SUCCESS&#10;            }&#10;&#10;            gattServer?.sendResponse(device, requestId, responseStatus, offset, responseValue)&#10;        }&#10;&#10;        override fun onCharacteristicWriteRequest(device: BluetoothDevice, requestId: Int, characteristic: BluetoothGattCharacteristic,&#10;                                                  preparedWrite: Boolean, responseNeeded: Boolean, offset: Int, value: ByteArray?) {&#10;            val deviceAddress = device.address&#10;            log(&quot;Write request from $deviceAddress&quot;)&#10;&#10;            var responseStatus = BluetoothGatt.GATT_FAILURE&#10;            if (characteristic.uuid == CHARACTERISTIC_UUID_WRITE || characteristic.uuid == CHARACTERISTIC_UUID_READ) {&#10;                val message = value?.toString(Charsets.UTF_8) ?: &quot;null&quot;&#10;                log(&quot;Received: $message from $deviceAddress&quot;)&#10;                onMessageReceived?.invoke(message)&#10;                responseStatus = BluetoothGatt.GATT_SUCCESS&#10;            }&#10;&#10;            if (responseNeeded) {&#10;                gattServer?.sendResponse(device, requestId, responseStatus, offset, value)&#10;            }&#10;        }&#10;&#10;        override fun onDescriptorWriteRequest(device: BluetoothDevice, requestId: Int, descriptor: BluetoothGattDescriptor,&#10;                                              preparedWrite: Boolean, responseNeeded: Boolean, offset: Int, value: ByteArray?) {&#10;            var responseStatus = BluetoothGatt.GATT_FAILURE&#10;            if (descriptor.uuid == CCCD_UUID) {&#10;                responseStatus = BluetoothGatt.GATT_SUCCESS&#10;                when {&#10;                    value.contentEquals(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE) -&gt;&#10;                        log(&quot;Notifications enabled by ${device.address}&quot;)&#10;                    value.contentEquals(BluetoothGattDescriptor.ENABLE_INDICATION_VALUE) -&gt;&#10;                        log(&quot;Indications enabled by ${device.address}&quot;)&#10;                    else -&gt;&#10;                        log(&quot;Notifications disabled by ${device.address}&quot;)&#10;                }&#10;            }&#10;&#10;            if (responseNeeded) {&#10;                gattServer?.sendResponse(device, requestId, responseStatus, offset, null)&#10;            }&#10;        }&#10;&#10;        override fun onNotificationSent(device: BluetoothDevice, status: Int) {&#10;            log(&quot;Notification sent to ${device.address}, Status: ${if (status == BluetoothGatt.GATT_SUCCESS) &quot;Success&quot; else &quot;Failure&quot;}&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        log(&quot;Service destroyed&quot;)&#10;        stopCurrentRole()&#10;        handler.removeCallbacksAndMessages(null)&#10;    }&#10;&#10;    fun getConnectedDevices(): List&lt;ConnectedDevice&gt; {&#10;        return connectedGattClients.values.toList()&#10;    }&#10;&#10;    fun getConnectedClients(): List&lt;BluetoothDevice&gt; {&#10;        return connectedClientMap.values.toList()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.myapplication3&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.app.*&#10;import android.bluetooth.*&#10;import android.bluetooth.le.*&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Binder&#10;import android.os.Build&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.os.ParcelUuid&#10;import android.util.Log&#10;import androidx.annotation.RequiresApi&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.content.ContextCompat&#10;import com.example.myapplication3.BleRole.*&#10;import java.util.UUID&#10;import java.util.concurrent.ConcurrentHashMap&#10;&#10;@SuppressLint(&quot;MissingPermission&quot;)&#10;class BleConnectionsService : Service() {&#10;&#10;    private val TAG = &quot;BleService&quot;&#10;    private val NOTIFICATION_ID = 2001&#10;    private val CHANNEL_ID = &quot;ble_connections_channel&quot;&#10;&#10;    // BLE Constants&#10;    private val SERVICE_UUID = UUID.fromString(&quot;6E400001-B5A3-F393-E0A9-E50E24DCCA9E&quot;)&#10;    private val CHARACTERISTIC_UUID_WRITE = UUID.fromString(&quot;00001102-0000-1000-8000-00805F9B34FB&quot;)&#10;    private val CHARACTERISTIC_UUID_NOTIFY = UUID.fromString(&quot;00001103-0000-1000-8000-00805F9B34FB&quot;)&#10;    private val CHARACTERISTIC_UUID_READ = UUID.fromString(&quot;00001104-0000-1000-8000-00805F9B34FB&quot;)&#10;    private val CCCD_UUID = UUID.fromString(&quot;00002902-0000-1000-8000-00805f9b34fb&quot;)&#10;&#10;    private val binder = LocalBinder()&#10;    private val handler = Handler(Looper.getMainLooper())&#10;&#10;    // BLE Managers&#10;    private var bluetoothManager: BluetoothManager? = null&#10;    private var bluetoothAdapter: BluetoothAdapter? = null&#10;    private var bleScanner: BluetoothLeScanner? = null&#10;    private var gattServer: BluetoothGattServer? = null&#10;    private var advertiser: BluetoothLeAdvertiser? = null&#10;&#10;    // State&#10;    var currentRole = IDLE&#10;        private set&#10;    var isScanning = false&#10;        private set&#10;    var isAdvertising = false&#10;        private set&#10;&#10;    // Data structures&#10;    private val discoveredDeviceMap = ConcurrentHashMap&lt;String, DiscoveredDevice&gt;()&#10;    private val connectedGattClients = ConcurrentHashMap&lt;String, ConnectedDevice&gt;()&#10;    private val connectedClientMap = ConcurrentHashMap&lt;String, BluetoothDevice&gt;()&#10;&#10;    // Characteristics&#10;    private var writeCharacteristicServer: BluetoothGattCharacteristic? = null&#10;    private var notifyCharacteristicServer: BluetoothGattCharacteristic? = null&#10;    private var readCharacteristicServer: BluetoothGattCharacteristic? = null&#10;&#10;    // Callbacks&#10;    var onRoleChanged: ((BleRole) -&gt; Unit)? = null&#10;    var onScanningStateChanged: ((Boolean) -&gt; Unit)? = null&#10;    var onAdvertisingStateChanged: ((Boolean) -&gt; Unit)? = null&#10;    var onDevicesDiscovered: ((List&lt;DiscoveredDevice&gt;) -&gt; Unit)? = null&#10;    var onDevicesConnected: ((List&lt;ConnectedDevice&gt;) -&gt; Unit)? = null&#10;    var onClientsConnected: ((List&lt;BluetoothDevice&gt;) -&gt; Unit)? = null&#10;    var onLogMessage: ((String) -&gt; Unit)? = null&#10;    var onMessageReceived: ((String) -&gt; Unit)? = null&#10;&#10;    inner class LocalBinder : Binder() {&#10;        fun getService(): BleConnectionsService = this@BleConnectionsService&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.d(TAG, &quot;BLE Service created&quot;)&#10;        bluetoothManager = getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager&#10;        bluetoothAdapter = bluetoothManager?.adapter&#10;        createNotificationChannel()&#10;&#10;        // Automatically start as peripheral and begin advertising&#10;        setRole(PERIPHERAL)&#10;        startPeripheralAdvertising()&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder {&#10;        Log.d(TAG, &quot;Service bound&quot;)&#10;        return binder&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        Log.d(TAG, &quot;Service started&quot;)&#10;        startForeground(NOTIFICATION_ID, createNotification(&quot;BLE Connections Active&quot;))&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;BLE Connections&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Running BLE Connections in background&quot;&#10;            }&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;            Log.d(TAG, &quot;Notification channel created&quot;)&#10;        }&#10;    }&#10;&#10;    private fun createNotification(message: String): Notification {&#10;        val notificationIntent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this,&#10;            0,&#10;            notificationIntent,&#10;            PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        return NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;BLE Connections&quot;)&#10;            .setContentText(message)&#10;            .setSmallIcon(android.R.drawable.stat_notify_sync)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .build()&#10;    }&#10;&#10;    private fun updateNotification(message: String) {&#10;        val notificationManager = getSystemService(NotificationManager::class.java)&#10;        notificationManager.notify(NOTIFICATION_ID, createNotification(message))&#10;        Log.d(TAG, &quot;Notification updated: $message&quot;)&#10;    }&#10;&#10;    private fun log(message: String) {&#10;        Log.d(TAG, message)&#10;        onLogMessage?.invoke(message)&#10;    }&#10;&#10;    private fun hasPermission(permission: String): Boolean {&#10;        return ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    // ============================================&#10;    // ROLE MANAGEMENT&#10;    // ============================================&#10;&#10;    fun setRole(role: BleRole) {&#10;        if (currentRole == role) return&#10;&#10;        stopCurrentRole()&#10;        currentRole = role&#10;        log(&quot;Switched role to: $role&quot;)&#10;        onRoleChanged?.invoke(role)&#10;&#10;        when (role) {&#10;            CENTRAL -&gt; {&#10;                isAdvertising = false&#10;                connectedClientMap.clear()&#10;                onClientsConnected?.invoke(emptyList())&#10;                updateNotification(&quot;Central Mode&quot;)&#10;            }&#10;            PERIPHERAL -&gt; {&#10;                isScanning = false&#10;                discoveredDeviceMap.clear()&#10;                connectedGattClients.clear()&#10;                onDevicesDiscovered?.invoke(emptyList())&#10;                onDevicesConnected?.invoke(emptyList())&#10;                updateNotification(&quot;Peripheral Mode&quot;)&#10;            }&#10;            IDLE -&gt; {&#10;                updateNotification(&quot;BLE Connections Active&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopCurrentRole() {&#10;        if (currentRole == PERIPHERAL) {&#10;            stopPeripheral()&#10;        }&#10;        currentRole = IDLE&#10;    }&#10;&#10;    // ============================================&#10;    // PERIPHERAL ROLE&#10;    // ============================================&#10;&#10;    fun startPeripheralAdvertising() {&#10;        if (currentRole != PERIPHERAL) {&#10;            log(&quot;Not in Peripheral role&quot;)&#10;            return&#10;        }&#10;        if (isAdvertising) {&#10;            log(&quot;Already advertising&quot;)&#10;            return&#10;        }&#10;        if (!hasPermission(Manifest.permission.BLUETOOTH_ADVERTISE)) {&#10;            log(&quot;BLUETOOTH_ADVERTISE permission missing&quot;)&#10;            return&#10;        }&#10;&#10;        advertiser = bluetoothAdapter?.bluetoothLeAdvertiser&#10;        if (advertiser == null) {&#10;            log(&quot;Failed to get BLE Advertiser&quot;)&#10;            return&#10;        }&#10;&#10;        if (!setupGattServer()) {&#10;            log(&quot;Failed to setup GATT Server&quot;)&#10;            return&#10;        }&#10;&#10;        val settings = AdvertiseSettings.Builder()&#10;            .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY)&#10;            .setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH)&#10;            .setConnectable(true)&#10;            .build()&#10;&#10;        val data = AdvertiseData.Builder()&#10;            .setIncludeDeviceName(false)&#10;            .addServiceUuid(ParcelUuid(SERVICE_UUID))&#10;            .build()&#10;&#10;        val scanResponse = AdvertiseData.Builder()&#10;            .setIncludeDeviceName(true)&#10;            .build()&#10;&#10;        log(&quot;Starting Advertising...&quot;)&#10;        updateNotification(&quot;Starting advertising...&quot;)&#10;        advertiser?.startAdvertising(settings, data, scanResponse, advertiseCallback)&#10;    }&#10;&#10;    fun stopPeripheralAdvertising() {&#10;        if (!isAdvertising) return&#10;        log(&quot;Stopping Advertising&quot;)&#10;        advertiser?.stopAdvertising(advertiseCallback)&#10;        isAdvertising = false&#10;        onAdvertisingStateChanged?.invoke(false)&#10;        updateNotification(&quot;Peripheral Mode&quot;)&#10;    }&#10;&#10;    private fun setupGattServer(): Boolean {&#10;        if (gattServer != null) {&#10;            log(&quot;GATT Server already running&quot;)&#10;            return true&#10;        }&#10;&#10;        gattServer = bluetoothManager?.openGattServer(this, gattServerCallback)&#10;        if (gattServer == null) {&#10;            log(&quot;Failed to open GATT Server&quot;)&#10;            return false&#10;        }&#10;&#10;        val service = BluetoothGattService(SERVICE_UUID, BluetoothGattService.SERVICE_TYPE_PRIMARY)&#10;&#10;        writeCharacteristicServer = BluetoothGattCharacteristic(&#10;            CHARACTERISTIC_UUID_WRITE,&#10;            BluetoothGattCharacteristic.PROPERTY_WRITE or BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE,&#10;            BluetoothGattCharacteristic.PERMISSION_WRITE&#10;        )&#10;&#10;        readCharacteristicServer = BluetoothGattCharacteristic(&#10;            CHARACTERISTIC_UUID_READ,&#10;            BluetoothGattCharacteristic.PROPERTY_READ,&#10;            BluetoothGattCharacteristic.PERMISSION_READ&#10;        )&#10;&#10;        notifyCharacteristicServer = BluetoothGattCharacteristic(&#10;            CHARACTERISTIC_UUID_NOTIFY,&#10;            BluetoothGattCharacteristic.PROPERTY_READ or BluetoothGattCharacteristic.PROPERTY_NOTIFY,&#10;            BluetoothGattCharacteristic.PERMISSION_READ&#10;        )&#10;&#10;        val cccdDescriptor = BluetoothGattDescriptor(&#10;            CCCD_UUID,&#10;            BluetoothGattDescriptor.PERMISSION_READ or BluetoothGattDescriptor.PERMISSION_WRITE&#10;        )&#10;        notifyCharacteristicServer?.addDescriptor(cccdDescriptor)&#10;        readCharacteristicServer?.addDescriptor(cccdDescriptor)&#10;&#10;        service.addCharacteristic(writeCharacteristicServer)&#10;        service.addCharacteristic(notifyCharacteristicServer)&#10;        service.addCharacteristic(readCharacteristicServer)&#10;&#10;        val serviceAdded = gattServer?.addService(service) ?: false&#10;        if (serviceAdded) {&#10;            log(&quot;GATT Service added successfully&quot;)&#10;            return true&#10;        } else {&#10;            log(&quot;Failed to add GATT Service&quot;)&#10;            gattServer?.close()&#10;            gattServer = null&#10;            return false&#10;        }&#10;    }&#10;&#10;    private fun stopGattServer() {&#10;        if (gattServer == null) return&#10;        log(&quot;Closing GATT Server&quot;)&#10;        gattServer?.close()&#10;        gattServer = null&#10;        writeCharacteristicServer = null&#10;        notifyCharacteristicServer = null&#10;        connectedClientMap.clear()&#10;        onClientsConnected?.invoke(emptyList())&#10;    }&#10;&#10;    private fun stopPeripheral() {&#10;        log(&quot;Stopping Peripheral Role...&quot;)&#10;        stopPeripheralAdvertising()&#10;        stopGattServer()&#10;        isAdvertising = false&#10;        connectedClientMap.clear()&#10;        onClientsConnected?.invoke(emptyList())&#10;    }&#10;&#10;    // ============================================&#10;    // SCAN CALLBACK&#10;    // ============================================&#10;&#10;    private val scanCallback = object : ScanCallback() {&#10;        override fun onScanResult(callbackType: Int, result: ScanResult) {&#10;            val device = result.device&#10;            val deviceName = result.scanRecord?.deviceName ?: device.name ?: &quot;Unknown&quot;&#10;            val deviceAddress = device.address&#10;&#10;            if (!discoveredDeviceMap.containsKey(deviceAddress)) {&#10;                log(&quot;Discovered: $deviceName ($deviceAddress)&quot;)&#10;                val discovered = DiscoveredDevice(deviceName, deviceAddress, device)&#10;                discoveredDeviceMap[deviceAddress] = discovered&#10;                onDevicesDiscovered?.invoke(discoveredDeviceMap.values.toList())&#10;            }&#10;        }&#10;&#10;        override fun onBatchScanResults(results: List&lt;ScanResult&gt;) {&#10;            results.forEach { result -&gt;&#10;                val device = result.device&#10;                val deviceName = result.scanRecord?.deviceName ?: device.name ?: &quot;Unknown&quot;&#10;                val deviceAddress = device.address&#10;                if (!discoveredDeviceMap.containsKey(deviceAddress)) {&#10;                    log(&quot;Discovered Batch: $deviceName ($deviceAddress)&quot;)&#10;                    discoveredDeviceMap[deviceAddress] = DiscoveredDevice(deviceName, deviceAddress, device)&#10;                }&#10;            }&#10;            onDevicesDiscovered?.invoke(discoveredDeviceMap.values.toList())&#10;        }&#10;&#10;        override fun onScanFailed(errorCode: Int) {&#10;            log(&quot;Scan Failed: Error Code $errorCode&quot;)&#10;            isScanning = false&#10;            onScanningStateChanged?.invoke(false)&#10;            updateNotification(&quot;Scan failed&quot;)&#10;        }&#10;    }&#10;&#10;    // ============================================&#10;    // GATT CLIENT CALLBACK&#10;    // ============================================&#10;&#10;    private val gattClientCallback = object : BluetoothGattCallback() {&#10;        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {&#10;            val deviceAddress = gatt.device.address&#10;            when (newState) {&#10;                BluetoothProfile.STATE_CONNECTED -&gt; {&#10;                    if (status == BluetoothGatt.GATT_SUCCESS) {&#10;                        log(&quot;Connected to $deviceAddress&quot;)&#10;                        connectedGattClients[deviceAddress] = ConnectedDevice(gatt.device, gatt)&#10;                        onDevicesConnected?.invoke(connectedGattClients.values.toList())&#10;                        updateNotification(&quot;Connected to ${gatt.device.name ?: deviceAddress}&quot;)&#10;&#10;                        log(&quot;Discovering services for $deviceAddress&quot;)&#10;                        val servicesDiscovered = gatt.discoverServices()&#10;                        if (!servicesDiscovered) {&#10;                            log(&quot;Failed to start service discovery&quot;)&#10;                            connectedGattClients.remove(deviceAddress)&#10;                            gatt.close()&#10;                            onDevicesConnected?.invoke(connectedGattClients.values.toList())&#10;                        }&#10;                    } else {&#10;                        log(&quot;Connection failed with status $status&quot;)&#10;                        connectedGattClients.remove(deviceAddress)&#10;                        gatt.close()&#10;                        onDevicesConnected?.invoke(connectedGattClients.values.toList())&#10;                    }&#10;                }&#10;                BluetoothProfile.STATE_DISCONNECTED -&gt; {&#10;                    log(&quot;Disconnected from $deviceAddress&quot;)&#10;                    connectedGattClients.remove(deviceAddress)&#10;                    gatt.close()&#10;                    onDevicesConnected?.invoke(connectedGattClients.values.toList())&#10;                    updateNotification(&quot;Device disconnected&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {&#10;            val deviceAddress = gatt.device.address&#10;            if (status == BluetoothGatt.GATT_SUCCESS) {&#10;                log(&quot;Services discovered for $deviceAddress&quot;)&#10;                val service = gatt.getService(SERVICE_UUID)&#10;                if (service != null) {&#10;                    val writeChar = service.getCharacteristic(CHARACTERISTIC_UUID_WRITE)&#10;                    val readChar = service.getCharacteristic(CHARACTERISTIC_UUID_READ)&#10;&#10;                    connectedGattClients[deviceAddress]?.let { connectedDevice -&gt;&#10;                        connectedDevice.writeCharacteristic = writeChar&#10;                        connectedDevice.readCharacteristic = readChar&#10;                        onDevicesConnected?.invoke(connectedGattClients.values.toList())&#10;                    }&#10;                } else {&#10;                    log(&quot;Service not found for $deviceAddress&quot;)&#10;                }&#10;            } else {&#10;                log(&quot;Service discovery failed with status $status&quot;)&#10;            }&#10;        }&#10;&#10;        override fun onCharacteristicWrite(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {&#10;            val deviceAddress = gatt.device.address&#10;            if (status == BluetoothGatt.GATT_SUCCESS) {&#10;                log(&quot;Write successful for $deviceAddress&quot;)&#10;                updateNotification(&quot;Write successful for $deviceAddress&quot;)&#10;            } else {&#10;                log(&quot;Write failed for $deviceAddress with status: $status&quot;)&#10;                updateNotification(&quot;Write failed for $deviceAddress with status: $status&quot;)&#10;            }&#10;        }&#10;&#10;        override fun onCharacteristicChanged(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, value: ByteArray) {&#10;            if (characteristic.uuid == CHARACTERISTIC_UUID_NOTIFY || characteristic.uuid == CHARACTERISTIC_UUID_READ) {&#10;                val receivedMessage = value.toString(Charsets.UTF_8)&#10;                log(&quot;Received: $receivedMessage&quot;)&#10;                onMessageReceived?.invoke(receivedMessage)&#10;                updateNotification(receivedMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    // ============================================&#10;    // ADVERTISE CALLBACK&#10;    // ============================================&#10;&#10;    private val advertiseCallback = object : AdvertiseCallback() {&#10;        override fun onStartSuccess(settingsInEffect: AdvertiseSettings) {&#10;            log(&quot;Advertising started successfully&quot;)&#10;            isAdvertising = true&#10;            onAdvertisingStateChanged?.invoke(true)&#10;            updateNotification(&quot;Advertising...&quot;)&#10;        }&#10;&#10;        override fun onStartFailure(errorCode: Int) {&#10;            log(&quot;Advertising failed: Error Code $errorCode&quot;)&#10;            isAdvertising = false&#10;            onAdvertisingStateChanged?.invoke(false)&#10;            updateNotification(&quot;Advertising failed&quot;)&#10;        }&#10;    }&#10;&#10;    // ============================================&#10;    // GATT SERVER CALLBACK&#10;    // ============================================&#10;&#10;    private val gattServerCallback = object : BluetoothGattServerCallback() {&#10;        override fun onConnectionStateChange(device: BluetoothDevice, status: Int, newState: Int) {&#10;            val deviceAddress = device.address&#10;            if (newState == BluetoothProfile.STATE_CONNECTED) {&#10;                log(&quot;Client connected: $deviceAddress&quot;)&#10;                connectedClientMap[deviceAddress] = device&#10;                onClientsConnected?.invoke(connectedClientMap.values.toList())&#10;                updateNotification(&quot;Client connected: ${device.name ?: deviceAddress}&quot;)&#10;                stopPeripheralAdvertising()&#10;            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {&#10;                log(&quot;Client disconnected: $deviceAddress&quot;)&#10;                connectedClientMap.remove(deviceAddress)&#10;                onClientsConnected?.invoke(connectedClientMap.values.toList())&#10;                updateNotification(&quot;Client disconnected&quot;)&#10;                startPeripheralAdvertising()&#10;            }&#10;        }&#10;&#10;        override fun onCharacteristicReadRequest(device: BluetoothDevice, requestId: Int, offset: Int, characteristic: BluetoothGattCharacteristic) {&#10;            log(&quot;Read request from ${device.address}&quot;)&#10;            var responseValue: ByteArray? = null&#10;            var responseStatus = BluetoothGatt.GATT_FAILURE&#10;&#10;            if (characteristic.uuid == CHARACTERISTIC_UUID_READ) {&#10;                responseValue = &quot;Time: ${System.currentTimeMillis()}&quot;.toByteArray(Charsets.UTF_8)&#10;                responseStatus = BluetoothGatt.GATT_SUCCESS&#10;            }&#10;&#10;            gattServer?.sendResponse(device, requestId, responseStatus, offset, responseValue)&#10;        }&#10;&#10;        override fun onCharacteristicWriteRequest(device: BluetoothDevice, requestId: Int, characteristic: BluetoothGattCharacteristic,&#10;                                                  preparedWrite: Boolean, responseNeeded: Boolean, offset: Int, value: ByteArray?) {&#10;            val deviceAddress = device.address&#10;            log(&quot;Write request from $deviceAddress&quot;)&#10;&#10;            var responseStatus = BluetoothGatt.GATT_FAILURE&#10;            if (characteristic.uuid == CHARACTERISTIC_UUID_WRITE || characteristic.uuid == CHARACTERISTIC_UUID_READ) {&#10;                val message = value?.toString(Charsets.UTF_8) ?: &quot;null&quot;&#10;                log(&quot;Received: $message from $deviceAddress&quot;)&#10;                onMessageReceived?.invoke(message)&#10;                responseStatus = BluetoothGatt.GATT_SUCCESS&#10;            }&#10;&#10;            if (responseNeeded) {&#10;                gattServer?.sendResponse(device, requestId, responseStatus, offset, value)&#10;            }&#10;        }&#10;&#10;        override fun onDescriptorWriteRequest(device: BluetoothDevice, requestId: Int, descriptor: BluetoothGattDescriptor,&#10;                                              preparedWrite: Boolean, responseNeeded: Boolean, offset: Int, value: ByteArray?) {&#10;            var responseStatus = BluetoothGatt.GATT_FAILURE&#10;            if (descriptor.uuid == CCCD_UUID) {&#10;                responseStatus = BluetoothGatt.GATT_SUCCESS&#10;                when {&#10;                    value.contentEquals(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE) -&gt;&#10;                        log(&quot;Notifications enabled by ${device.address}&quot;)&#10;                    value.contentEquals(BluetoothGattDescriptor.ENABLE_INDICATION_VALUE) -&gt;&#10;                        log(&quot;Indications enabled by ${device.address}&quot;)&#10;                    else -&gt;&#10;                        log(&quot;Notifications disabled by ${device.address}&quot;)&#10;                }&#10;            }&#10;&#10;            if (responseNeeded) {&#10;                gattServer?.sendResponse(device, requestId, responseStatus, offset, null)&#10;            }&#10;        }&#10;&#10;        override fun onNotificationSent(device: BluetoothDevice, status: Int) {&#10;            log(&quot;Notification sent to ${device.address}, Status: ${if (status == BluetoothGatt.GATT_SUCCESS) &quot;Success&quot; else &quot;Failure&quot;}&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        log(&quot;Service destroyed&quot;)&#10;        stopCurrentRole()&#10;        handler.removeCallbacksAndMessages(null)&#10;    }&#10;&#10;    fun getConnectedDevices(): List&lt;ConnectedDevice&gt; {&#10;        return connectedGattClients.values.toList()&#10;    }&#10;&#10;    fun getConnectedClients(): List&lt;BluetoothDevice&gt; {&#10;        return connectedClientMap.values.toList()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>